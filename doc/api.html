<!DOCTYPE HTML>
<html lang="en" >
    
    <head>
        
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <title>API reference | moderngpu</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="generator" content="GitBook 2.6.7">
        
        
        <meta name="HandheldFriendly" content="true"/>
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black">
        <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
        <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">
        
    <link rel="stylesheet" href="../gitbook/style.css">
    
        
        <link rel="stylesheet" href="../gitbook/plugins/gitbook-plugin-highlight/website.css">
        
    
        
        <link rel="stylesheet" href="../gitbook/plugins/gitbook-plugin-search/search.css">
        
    
        
        <link rel="stylesheet" href="../gitbook/plugins/gitbook-plugin-fontsettings/website.css">
        
    
    
        <link rel="stylesheet" href="../styles/website.css">
    

        
    
    
    <link rel="next" href="../doc/usage.html" />
    
    
    <link rel="prev" href="../doc/lbs.html" />
    

        
    </head>
    <body>
        
        
    <div class="book"
        data-level="5"
        data-chapter-title="API reference"
        data-filepath="doc/api.md"
        data-basepath=".."
        data-revision="Tue Apr 26 2016 00:13:48 GMT-0400 (EDT)"
        data-innerlanguage="">
    

<div class="book-summary">
    <nav role="navigation">
        <ul class="summary">
            
            
            
            

            

            
    
        <li class="chapter " data-level="0" data-path="index.html">
            
                
                    <a href="../index.html">
                
                        <i class="fa fa-check"></i>
                        
                        Introduction
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="1" data-path="doc/intro.html">
            
                
                    <a href="../doc/intro.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>1.</b>
                        
                        Introduction
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="2" data-path="doc/gettingstarted.html">
            
                
                    <a href="../doc/gettingstarted.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>2.</b>
                        
                        Getting started
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="3" data-path="doc/patterns.html">
            
                
                    <a href="../doc/patterns.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>3.</b>
                        
                        Patterns and behaviors
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="4" data-path="doc/lbs.html">
            
                
                    <a href="../doc/lbs.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>4.</b>
                        
                        Load-balancing search
                    </a>
            
            
        </li>
    
        <li class="chapter active" data-level="5" data-path="doc/api.html">
            
                
                    <a href="../doc/api.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>5.</b>
                        
                        API reference
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="6" data-path="doc/usage.html">
            
                
                    <a href="../doc/usage.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>6.</b>
                        
                        Usage notes
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="7" data-path="LICENSE.html">
            
                
                    <a href="../LICENSE.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>7.</b>
                        
                        License
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="8" data-path="doc/moderngpu_1.0.html">
            
                
                    <a href="../doc/moderngpu_1.0.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>8.</b>
                        
                        moderngpu 1.0
                    </a>
            
            
        </li>
    


            
            <li class="divider"></li>
            <li>
                <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
                    Published with GitBook
                </a>
            </li>
            
        </ul>
    </nav>
</div>

    <div class="book-body">
        <div class="body-inner">
            <div class="book-header" role="navigation">
    <!-- Actions Left -->
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../" >moderngpu</a>
    </h1>
</div>

            <div class="page-wrapper" tabindex="-1" role="main">
                <div class="page-inner">
                
                
                    <section class="normal" id="section-">
                    
                        <h1 id="api-reference">API Reference</h1>
<p>moderngpu includes functions that operate on iterators and functions that operate on user-provided lambdas. Often these are just two sides of the same coin--you can adapt an iterator to a lambda-accepting function by dereferencing the iterator, and you can adapt a lambda to an iterator-accepting function by using the library&apos;s <code>make_load_iterator</code> and <code>make_store_iterator</code> functions to wrap the lambda. </p>
<p>Many of the lambda-accepting functions are called <em>transforms</em>. They vary in sophistication, but each of them is useful in solving real-world problems. The transforms are very expressive, and several of moderngpu&apos;s library routines are just calls to one or more transforms specialized over simple lambdas. With this set of tools it&apos;s possible to build an entire GPU-accelerated application without writing any of your own kernels.</p>
<h2 id="lowlevel-transforms">Low-level transforms</h2>
<h4 id="transform">transform</h4>
<p><strong><code>transform.hxx</code></strong></p>
<pre><code class="lang-cpp"><span class="hljs-keyword">template</span>&lt;
  <span class="hljs-keyword">size_t</span> nt = <span class="hljs-number">128</span>,        <span class="hljs-comment">// num threads per CTA. blockDim.x.</span>
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">func_t</span>         <span class="hljs-comment">// implements void operator()(int index).</span>
&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">transform</span><span class="hljs-params">(func_t f, size_t count, context_t&amp; context)</span></span>;
</code></pre>
<p><code>transform</code> simply wraps the CUDA launch chevrons <code>&lt;&lt;&lt; &gt;&gt;&gt;</code> and calls a function on each of the <code>count</code> threads, to which it passes the global index of the thread, <code>threadIdx.x + blockIdx.x * blockDim.x</code>.</p>
<h4 id="ctalaunch">cta_launch</h4>
<p><strong><code>transform.hxx</code></strong></p>
<pre><code class="lang-cpp"><span class="hljs-keyword">template</span>&lt;                 
  <span class="hljs-keyword">typename</span> launch_box,     <span class="hljs-comment">// structure providing nt.</span>
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">func_t</span>          <span class="hljs-comment">// implements void operator()(int tid, int cta).</span>
&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cta_launch</span><span class="hljs-params">(func_t f, <span class="hljs-keyword">int</span> num_ctas, context_t&amp; context)</span></span>;

<span class="hljs-comment">// Specialize over nt directly.</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> nt, <span class="hljs-keyword">typename</span> <span class="hljs-keyword">func_t</span>&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cta_launch</span><span class="hljs-params">(func_t f, <span class="hljs-keyword">int</span> num_ctas, context_t&amp; context)</span></span>;

<span class="hljs-comment">// Dynamically loop over the number of CTAs in num_ctas.</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> launch_box, <span class="hljs-keyword">typename</span> <span class="hljs-keyword">func_t</span>&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cta_launch</span><span class="hljs-params">(func_t f, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>* num_ctas, context_t&amp; context)</span></span>;s
</code></pre>
<p><code>cta_launch</code> is the next level of transform. Rather than launching individual threads, it creates <em>cooperative thread arrays</em> (CTAs, also known, less descriptively, as <em>thread blocks</em>). This transformer takes as a template argument the size of the CTA in threads. This compile-time constant <code>nt</code> can be used for sizing shared memory and defining structural aspects in the code, such as the number of iterations in an unrolled loop. The caller specifies the number of CTAs to launch, and the provided lambda is invoked on each thread in each of those CTAs. </p>
<h4 id="ctatransform">cta_transform</h4>
<p><strong><code>transform.hxx</code></strong></p>
<pre><code class="lang-cpp"><span class="hljs-keyword">template</span>&lt;
  <span class="hljs-keyword">typename</span> launch_box,     <span class="hljs-comment">// structure providing (nt, vt).</span>
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">func_t</span>          <span class="hljs-comment">// implements void operator()(int tid, int cta).</span>
&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cta_transform</span><span class="hljs-params">(func_t f, <span class="hljs-keyword">int</span> count, context_t&amp; context)</span></span>;

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> nt, <span class="hljs-keyword">int</span> vt = <span class="hljs-number">1</span>, <span class="hljs-keyword">typename</span> <span class="hljs-keyword">func_t</span>&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cta_transform</span><span class="hljs-params">(func_t f, <span class="hljs-keyword">int</span> count, context_t&amp; context)</span></span>;
</code></pre>
<p><code>cta_transform</code> is the workhorse transformer of moderngpu 2.0. It&apos;s used internally to implement most of the library&apos;s high-level transforms. The caller specifies a <code>count</code> of work-items and the transformer creates enough CTAs to cover them. Each CTA processes <code>nt * vt</code> work-items. <code>nt</code> is the number of threads per CTA. <code>vt</code> is the <em>grain size</em> of the kernel, or the number of work-items processed per thread. These constants are typically loaded from a <em>launch box</em> which specifies launch parameters on a per-architecture basis.</p>
<p>The provided kernel function <code>f</code> is called once per thread in each of the launched CTAs. Handling fractional tiles is the user&apos;s responsibility. </p>
<h2 id="highlevel-transforms">High-level transforms</h2>
<h4 id="transformreduce">transform_reduce</h4>
<p><strong><code>kernel_reduce.hxx</code></strong></p>
<pre><code class="lang-cpp"><span class="hljs-keyword">template</span>&lt;
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">launch_arg_t</span> = <span class="hljs-keyword">empty_t</span>,  <span class="hljs-comment">// optional launch_box overrides default.</span>
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">func_t</span>,         <span class="hljs-comment">// implements type_t operator()(int index).</span>
  <span class="hljs-keyword">typename</span> output_it,      <span class="hljs-comment">// iterator to output. one output element.</span>
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">op_t</span>            <span class="hljs-comment">// reduction operator implements</span>
                           <span class="hljs-comment">//   type_t operator()(type_t left, type_t right).</span>
&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">transform_reduce</span><span class="hljs-params">(func_t f, <span class="hljs-keyword">int</span> count, output_it reduction, op_t op, 
  context_t&amp; context)</span></span>;
</code></pre>
<p><code>transform_reduce</code> invokes the caller-supplied lambda and adds together all the results. This is the same parallel reduction algorithm included in every CUDA computing library, but is presented here with more convenient lambda-centric packaging.</p>
<h4 id="transformscan">transform_scan</h4>
<p><strong><code>kernel_scan.hxx</code></strong></p>
<pre><code class="lang-cpp"><span class="hljs-keyword">template</span>&lt;
  <span class="hljs-keyword">scan_type_t</span> scan_type = scan_type_exc, <span class="hljs-comment">// inclusive or exclusive scan.</span>
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">launch_arg_t</span> = <span class="hljs-keyword">empty_t</span>,
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">func_t</span>,         <span class="hljs-comment">// implements type_t operator()(int index).</span>
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">op_t</span>,           <span class="hljs-comment">// reduction operator implements </span>
                           <span class="hljs-comment">//   type_t operator()(type_t a, type_t b).</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">transform_scan</span><span class="hljs-params">(func_t f, <span class="hljs-keyword">int</span> count, output_it output, op_t op,
  reduction_it reduction, context_t&amp; context)</span></span>;
</code></pre>
<p><code>transform_scan</code> invokes the provided lambda and computes a prefix sum over all elements. The reduction is also returned. In fact, by utilizing the <em>lambda iterator</em> feature in moderngpu 2.0, you can get the reduction or even the output of the scan itself passed to additional <code>__device__</code>-tagged lambdas that you provide. The distinction between <em>iterators</em> (a generalization of pointers) and <em>functions</em> is mostly about syntax rather than functionality.</p>
<h4 id="transformsegreduce">transform_segreduce</h4>
<p><strong><code>kernel_segreduce.hxx</code></strong></p>
<pre><code class="lang-cpp"><span class="hljs-keyword">template</span>&lt;
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">launch_arg_t</span> = <span class="hljs-keyword">empty_t</span>, <span class="hljs-comment">// provides constants (nt, vt, vt0).</span>
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">func_t</span>,         <span class="hljs-comment">// implements type_t operator()(int index).</span>
  <span class="hljs-keyword">typename</span> segments_it,    <span class="hljs-comment">// segments-descriptor array.</span>
                           <span class="hljs-comment">//   specificies starting offset of each segment.</span>
  <span class="hljs-keyword">typename</span> output_it,      <span class="hljs-comment">// output iterator. one output per segment.</span>
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">op_t</span>,           <span class="hljs-comment">// reduction operator implements</span>
                           <span class="hljs-comment">//   type_t operator()(type_t a, type_t b)</span>
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">type_t</span>
&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">transform_segreduce</span><span class="hljs-params">(func_t f, <span class="hljs-keyword">int</span> count, segments_it segments, 
  <span class="hljs-keyword">int</span> num_segments, output_it output, op_t op, type_t init, 
  context_t&amp; context)</span></span>;
</code></pre>
<p><code>transform_segreduce</code> reduces irregularly-sized sequences of values, called segments, using a reduction operator (such as <code>mgpu::plus_t&lt;&gt;</code>). An initialization value is provided for the reduction of empty segments. Segments are described by an integer array where each element indicates the beginning of that segment within a single flattened view of the operation. The first segment starts at 0 (so segments[0] = 0), and each subsequent segments-descriptor element is advanced by the size of the previous segment. That is, the segments descriptor is the exclusive prefix sum of the segment sizes. This is a common convention, and is known in graph and sparse matrix literature as the <a href="https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_row_.28CSR.2C_CRS_or_Yale_format.29" target="_blank">compressed sparse row</a> format.</p>
<p>Functions that use load-balancing search internally, such as <code>transform_segreduce</code>, specialize over a <code>vt0</code> parameter in the launch parameters. If not specified, the launch box mechanism defaults <code>vt0</code> to <code>vt</code>. <code>vt0</code> is a caching term which specifies the number of unconditional loads to execute per thread. Segment geometries with more values per segment will benefit from increasing <code>vt0</code>, while geometries with smaller segments may benefit from decreasing <code>vt0</code>. A rule of thumb is to set vt0 to </p>
<pre><code>vt0 = floor(vt * count / (count + num_segments))
</code></pre><p>if this ratio can be reasonably estimated in advance.</p>
<h4 id="transformlbs">transform_lbs</h4>
<p><strong><code>kernel_load_balance.hxx</code></strong></p>
<pre><code class="lang-cpp"><span class="hljs-keyword">template</span>&lt;
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">launch_arg_t</span> = <span class="hljs-keyword">empty_t</span>, <span class="hljs-comment">// provides (nt, vt, vt0)</span>
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">func_t</span>,         <span class="hljs-comment">// load-balancing search callback implements</span>
                           <span class="hljs-comment">//   void operator()(int index,   // work-item</span>
                           <span class="hljs-comment">//                   int seg,     // segment ID</span>
                           <span class="hljs-comment">//                   int rank,    // rank within seg</span>
                           <span class="hljs-comment">//                   tuple&lt;...&gt; cached_values).</span>
  <span class="hljs-keyword">typename</span> segments_it,    <span class="hljs-comment">// segments-descriptor array.</span>
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">tpl_t</span>           <span class="hljs-comment">// tuple&lt;&gt; of iterators for caching loads.</span>
&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">transform_lbs</span><span class="hljs-params">(func_t f, <span class="hljs-keyword">int</span> count, segments_it segments, 
  <span class="hljs-keyword">int</span> num_segments, tpl_t caching_iterators, context_t&amp; context)</span></span>;

<span class="hljs-comment">// version of transform_lbs without caching iterators</span>
<span class="hljs-keyword">template</span>&lt;
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">launch_arg_t</span> = <span class="hljs-keyword">empty_t</span>, 
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">func_t</span>,         <span class="hljs-comment">// load-balancing search callback implements</span>
                           <span class="hljs-comment">//   void operator()(int index, int seg, int rank).</span>
  <span class="hljs-keyword">typename</span> segments_it
&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">transform_lbs</span><span class="hljs-params">(func_t f, <span class="hljs-keyword">int</span> count, segments_it segments, 
  <span class="hljs-keyword">int</span> num_segments, context_t&amp; context)</span></span>;
</code></pre>
<p><code>transform_lbs</code> is the new front-end to the <em>load-balancing search</em> pattern introduced in moderngpu 1.0. The caller describes a collection of irregularly-sized <em>segments</em> with an array that indexes into the start of each segment. (This is identical to the prefix sum of the segment sizes.) Load-balancing search restores shape to this flattened array by calling your lambda once for each element in each segment and passing the segment identifier and the rank of the element within that segment. Unlike ad hoc scheduling methods which assign a thread, or a warp, or a thread-block to a segment, <em>load-balancing search</em> is robust with respect to the shape of the problem; you can bet on consistently good performance for all conditions. This is a truly powerful mechanism and a surprising number of useful functions can be defined with one-line lambdas using <code>transform_lbs</code>. Consider it the data science <em>mapper</em> of CUDA programs.</p>
<h4 id="lbssegreduce">lbs_segreduce</h4>
<p><strong><code>kernel_segreduce.hxx</code></strong></p>
<pre><code class="lang-cpp"><span class="hljs-keyword">template</span>&lt;
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">launch_arg_t</span> = <span class="hljs-keyword">empty_t</span>, <span class="hljs-comment">// provides (nt, vt, vt0)</span>
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">func_t</span>,         <span class="hljs-comment">// load-balancing search callback implements</span>
                           <span class="hljs-comment">//   type_t operator()(int index,   // work-item</span>
                           <span class="hljs-comment">//                     int seg,     // segment ID</span>
                           <span class="hljs-comment">//                     int rank,    // rank within seg</span>
                           <span class="hljs-comment">//                     tuple&lt;...&gt; cached_values).</span>
  <span class="hljs-keyword">typename</span> segments_it,    <span class="hljs-comment">// segments-descriptor array.</span>
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">tpl_t</span>,          <span class="hljs-comment">// tuple&lt;&gt; of iterators for caching loads.</span>
  <span class="hljs-keyword">typename</span> output_it,      <span class="hljs-comment">// output iterator. one output per segment.</span>
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">op_t</span>,           <span class="hljs-comment">// reduction operator implements</span>
                           <span class="hljs-comment">//   type_t operator()(type_t a, type_t b).</span>
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">type_t</span>
&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lbs_segreduce</span><span class="hljs-params">(func_t f, <span class="hljs-keyword">int</span> count, segments_it segments,
  <span class="hljs-keyword">int</span> num_segments, tpl_t caching_iterators, output_it output, op_t op,
  type_t init, context_t&amp; context)</span></span>;

<span class="hljs-comment">// version of lbs_segreduce without caching iterators.</span>
<span class="hljs-keyword">template</span>&lt;
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">launch_arg_t</span> = <span class="hljs-keyword">empty_t</span>, 
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">func_t</span>,         <span class="hljs-comment">// load-balancing search callback implements</span>
                           <span class="hljs-comment">//   type_t operator()(int index, int seg, int rank).</span>
  <span class="hljs-keyword">typename</span> segments_it, 
  <span class="hljs-keyword">typename</span> output_it, 
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">op_t</span>,
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">type_t</span>
&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lbs_segreduce</span><span class="hljs-params">(func_t f, <span class="hljs-keyword">int</span> count, segments_it segments,
  <span class="hljs-keyword">int</span> num_segments, output_it output, op_t op, type_t init, 
  context_t&amp; context)</span></span>;
</code></pre>
<p><code>lbs_segreduce</code> combines <code>transform_lbs</code> with segmented reduction. The caller&apos;s lambda is invoked with the segment ID and rank for each element, but the return values are folded into a single element per segment. <code>lbs_segreduce</code> is like a simultaneous mapper and reducer: each segment is expanded into an irregular number of work-items; a user-provided function is called on each work-item; then the results are reduced according to the segment geometry. This is the most sophisticated mechanism in moderngpu 2.0, and makes data science operations very easy to program.</p>
<h4 id="transformcompact">transform_compact</h4>
<p><strong><code>kernel_compact.hxx</code></strong></p>
<pre><code class="lang-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> <span class="hljs-keyword">launch_arg_t</span> = <span class="hljs-keyword">empty_t</span>&gt;
<span class="hljs-keyword">stream_compact_t</span>&lt;<span class="hljs-keyword">launch_arg_t</span>&gt; 
transform_compact(<span class="hljs-keyword">int</span> count, <span class="hljs-keyword">context_t</span>&amp; context);

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> <span class="hljs-keyword">launch_arg_t</span>&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-keyword">stream_compact_t</span> {
  ...
<span class="hljs-keyword">public</span>:
  <span class="hljs-comment">// upsweep of stream compaction. </span>
  <span class="hljs-comment">// func_t implements bool operator(int index);</span>
  <span class="hljs-comment">// The return value is flag for indicating that we want to *keep* the data</span>
  <span class="hljs-comment">// in the compacted stream.</span>
  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> <span class="hljs-keyword">func_t</span>&gt;
  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">upsweep</span><span class="hljs-params">(func_t f)</span></span>;

  <span class="hljs-comment">// downsweep of stream compaction.</span>
  <span class="hljs-comment">// func_t implements void operator(int dest_index, int source_index).</span>
  <span class="hljs-comment">// The user can stream from data[source_index] to compacted[dest_index].</span>
  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> <span class="hljs-keyword">func_t</span>&gt;
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">downsweep</span><span class="hljs-params">(func_t f)</span></span>;
};
</code></pre>
<p><code>transform_compact</code> is a two-pass pattern for space-efficient stream compaction. The user constructs a <code>stream_compact_t</code> object by calling <code>transform_compact</code>. On the upsweep, the user provides a lambda function which returns <code>true</code> to retain the specified <code>index</code> in the streamed output. On the downsweep, the user implements a <code>void</code>-returning lambda which takes the index to stream to and the index to stream from. The user may implement any element-wise copy or transformation in the body of this lambda.</p>
<p><strong><code>test_compact.cu</code></strong></p>
<pre><code class="lang-cpp">    <span class="hljs-comment">// Construct the compaction state with transform_compact.</span>
    <span class="hljs-keyword">auto</span> compact = transform_compact(count, context);

    <span class="hljs-comment">// The upsweep determines which items to compact.</span>
    <span class="hljs-keyword">int</span> stream_count = compact.upsweep([]MGPU_DEVICE(<span class="hljs-keyword">int</span> index) {
      <span class="hljs-comment">// Return true if we want to keep this element.</span>
      <span class="hljs-comment">// Only stream if the number of bits in index is a multiple of 5.</span>
      <span class="hljs-keyword">bool</span> keep = <span class="hljs-number">0</span> == (popc(index) % <span class="hljs-number">5</span>);
      <span class="hljs-keyword">return</span> keep;
    });

    <span class="hljs-comment">// Compact the results into this buffer.</span>
    <span class="hljs-keyword">mem_t</span>&lt;<span class="hljs-keyword">int</span>&gt; special_numbers(stream_count, context);
    <span class="hljs-keyword">int</span>* special_numbers_data = special_numbers.data();
    compact.downsweep([=]MGPU_DEVICE(<span class="hljs-keyword">int</span> dest_index, <span class="hljs-keyword">int</span> source_index) {
      special_numbers_data[dest_index] = source_index;
    });
</code></pre>
<p><code>test_compact.cu</code> demonstrates a simple usage of moderngpu&apos;s stream compaction. In this sample, all indices with a multiple of 5 bits set in the index&apos;s binary representation are compacted. The first statement uses <code>transform_compact</code> to construct a <code>stream_compact_t</code> object; this contains temporary state to communicate compaction information between CTAs. </p>
<p>The <code>upsweep</code> call is a lambda that returns <code>true</code> to keep the index and <code>false</code> to discard it. In this example, the lambda does not capture any variables from the enclosing scope, but it may. The return value is the total number of values to compact. The client uses this to allocate exactly enough memory to hold the streamed outputs.</p>
<p>In the <code>downsweep</code> call the lambda is provided both the index to stream to and the index to stream from. In this example, the lambda simply stores the source index into the compacted array, but any operation is admitted.</p>
<p><a href="https://thrust.github.io/doc/group__stream__compaction.html" target="_blank">stream compaction in thrust:</a></p>
<pre><code class="lang-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> InputIterator1 , <span class="hljs-keyword">typename</span> InputIterator2 , <span class="hljs-keyword">typename</span> OutputIterator , <span class="hljs-keyword">typename</span> Predicate &gt;
OutputIterator thrust::copy_if (InputIterator1 first, InputIterator1 last, InputIterator2 stencil, OutputIterator result, Predicate pred);

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> InputIterator , <span class="hljs-keyword">typename</span> OutputIterator , <span class="hljs-keyword">typename</span> T &gt;
OutputIterator  thrust::remove_copy (InputIterator first, InputIterator last, OutputIterator result, <span class="hljs-keyword">const</span> T &amp;value)

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> InputIterator , <span class="hljs-keyword">typename</span> OutputIterator , <span class="hljs-keyword">typename</span> Predicate &gt;
OutputIterator  thrust::remove_copy_if (InputIterator first, InputIterator last, OutputIterator result, Predicate pred);

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> InputIterator , <span class="hljs-keyword">typename</span> OutputIterator &gt;
OutputIterator  thrust::unique_copy (InputIterator first, InputIterator last, OutputIterator result);
...
</code></pre>
<p>This explicit two-pass process is better than the stream compaction functionality available in <a href="https://thrust.github.io/doc/group__stream__compaction.html" target="_blank">thrust</a>. In those functions the size of the compacted output is returned to the caller only after the stream compaction has completed. (It is implied by the position of the return iterator minus <code>result</code>). The user may need to <em>over-allocate</em> storage for the results, conservatively allocating enough space to copy the entire input array into the output.</p>
<p>thrust also defines dozens of related stream compactions such as <code>copy_if</code>, <code>remove_copy_if</code>, <code>unique_copy</code>, <code>unique_by_key_copy</code>, etc. These cases are all handled by <code>transform_compact</code>&apos;s <code>upsweep</code> lambda. <code>copy_if</code> has behavior like our test case, testing a single value and returning <code>true</code> to keep it. </p>
<p><code>unique_copy</code> keeps only the first element in a group of duplicate elements. A lambda can implement this behavior by simply returning <code>!index || data[index] != data[index - 1]</code>. That is, an element is streamed if and only if it has a different value from the preceding element.</p>
<p>moderngpu provides more coverage of functionality with many fewer functions than other libraries by recognizing different categories of operations and allowing the user to specialize behavior.</p>
<h4 id="lbsworkcreate">lbs_workcreate</h4>
<p><strong><code>kernel_workcreate.hxx</code></strong></p>
<pre><code class="lang-cpp"><span class="hljs-keyword">namespace</span> expt {

<span class="hljs-comment">// Use lbs_workcreate to construct an expt::workcreate_t instance. Then call</span>
<span class="hljs-comment">// upsweep and downsweep, providing an appropriate lambda function.</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> <span class="hljs-keyword">launch_arg_t</span> = <span class="hljs-keyword">empty_t</span>, <span class="hljs-keyword">typename</span> segments_it&gt;
<span class="hljs-keyword">workcreate_t</span>&lt;<span class="hljs-keyword">launch_arg_t</span>, segments_it&gt;
lbs_workcreate(<span class="hljs-keyword">int</span> count, segments_it segments, <span class="hljs-keyword">int</span> num_segments,
  <span class="hljs-keyword">context_t</span>&amp; context) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">workcreate_t</span>&lt;<span class="hljs-keyword">launch_arg_t</span>, segments_it&gt; {
    count, segments, num_segments, context
  };
}

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> <span class="hljs-keyword">launch_arg_t</span>, <span class="hljs-keyword">typename</span> segments_it&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-keyword">workcreate_t</span> {
  ...
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">struct</span> <span class="hljs-keyword">count_t</span> {
    <span class="hljs-keyword">int</span> count;
    <span class="hljs-keyword">int</span> num_segments;
  };

  <span class="hljs-comment">// f(int index, int seg, int rank, tuple&lt;...&gt; desc) returns the number</span>
  <span class="hljs-comment">// of work-items to create.</span>
  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> <span class="hljs-keyword">func_t</span>, <span class="hljs-keyword">typename</span> <span class="hljs-keyword">tpl_t</span>&gt;
  <span class="hljs-keyword">count_t</span> upsweep(<span class="hljs-keyword">func_t</span> f, <span class="hljs-keyword">tpl_t</span> caching_iterators);

  <span class="hljs-comment">// upsweep without caching iterators.</span>
  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> <span class="hljs-keyword">func_t</span>&gt;
  <span class="hljs-keyword">count_t</span> upsweep(<span class="hljs-keyword">func_t</span> f);

  <span class="hljs-comment">// f(int dest_seg, int index, int source_seg, int rank, tuple&lt;...&gt; desc)</span>
  <span class="hljs-comment">// returns the number of work-items to create.</span>
  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> <span class="hljs-keyword">func_t</span>, <span class="hljs-keyword">typename</span> <span class="hljs-keyword">tpl_t</span>&gt;
  <span class="hljs-keyword">mem_t</span>&lt;<span class="hljs-keyword">int</span>&gt; downsweep(<span class="hljs-keyword">func_t</span> f, <span class="hljs-keyword">tpl_t</span> caching_iterators);

  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> <span class="hljs-keyword">func_t</span>&gt;
  <span class="hljs-keyword">mem_t</span>&lt;<span class="hljs-keyword">int</span>&gt; downsweep(<span class="hljs-keyword">func_t</span> f);
};

} <span class="hljs-comment">// namespace expt</span>
</code></pre>
<p><code>lbs_workcreate</code> returns the state for a two-pass load-balancing search work-creation process. This function is included in the <code>mgpu::expt</code> namespace to reflect its experimental status.</p>
<p><code>lbs_workcreate</code> is called similarly to <code>transform_lbs</code>. The work-item count and segments-descriptor array are passed as arguments, and have the same meaning as in <code>transform_lbs</code>. However these individual work-items now have the capability of <em>dynamic work creation</em>. This function returns a <code>workcreate_t</code> object, on which <code>upstream</code> and <code>downstream</code> calls are made by the client. <code>upsweep</code> returns a <code>count_t</code> structure with the number of total work-items and segments generated.</p>
<ol>
<li><code>upsweep</code> is called for every work-item in the work load and returns the number of work-items to create. If the return count is greater than 0, one new <em>segment</em> of work will is emitted. That segment will have <em>count</em> number of ranks associated with it. This call can be non-deterministic. The <a href="#improved-breadth-first-search">improved breadth-first search</a> demo uses the CUDA intrinsic <code>atomicCAS</code> to non-deterministically generate work for newly-visited vertices.</li>
<li><code>downsweep</code> once again returns the number of work-items to create (it must match what it returned in <code>upsweep</code>), however <code>downsweep</code> is only invoked on work-items that attempted to generate new work in <code>upstream</code>. During this second pass the callback lambda <code>f</code> is also provided with the index of the newly-created segment of work. The caller should stream to this index information for processing the work in this segment. The function returns the segments-descriptor array of the dynamically-created work.</li>
</ol>
<p>Because the implementation has no knowledge of the number of work-items opting for dynamic work creation it cannot size the segments-descriptor array; nor does it choose to store the work-creation requests for each work-item. It therefore makes two passes. The first pass requests the number of work-items created. This is scanned on a per-CTA basis, and passed to the second pass, which again requests the number of work-items created, adds that to the running total of work-items, and stores to the new segments-descriptor array.</p>
<p>This pattern is constructed by fusing together the operations of load-balancing search, stream compaction, and scan to enable the user to dispatch work-items and dynamically create new ones.</p>
<h2 id="array-functions">Array functions</h2>
<h4 id="reduce">reduce</h4>
<p><strong><code>kernel_reduce.hxx</code></strong></p>
<pre><code class="lang-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> <span class="hljs-keyword">launch_arg_t</span> = <span class="hljs-keyword">empty_t</span>, <span class="hljs-keyword">typename</span> input_it, 
  <span class="hljs-keyword">typename</span> output_it, <span class="hljs-keyword">typename</span> <span class="hljs-keyword">op_t</span>&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reduce</span><span class="hljs-params">(input_it input, <span class="hljs-keyword">int</span> count, output_it reduction, op_t op, 
  context_t&amp; context)</span></span>;
</code></pre>
<h4 id="scan">scan</h4>
<p><strong><code>kernel_scan.hxx</code></strong></p>
<pre><code class="lang-cpp">
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">scan_type_t</span> scan_type = scan_type_exc,
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">launch_arg_t</span> = <span class="hljs-keyword">empty_t</span>, <span class="hljs-keyword">typename</span> input_it, 
  <span class="hljs-keyword">typename</span> output_it, <span class="hljs-keyword">typename</span> <span class="hljs-keyword">op_t</span>, <span class="hljs-keyword">typename</span> reduction_it&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">scan_event</span><span class="hljs-params">(input_it input, <span class="hljs-keyword">int</span> count, output_it output, op_t op, 
  reduction_it reduction, context_t&amp; context, cudaEvent_t event)</span></span>;

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">scan_type_t</span> scan_type = scan_type_exc, 
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">launch_arg_t</span> = <span class="hljs-keyword">empty_t</span>, <span class="hljs-keyword">typename</span> input_it, 
  <span class="hljs-keyword">typename</span> output_it, <span class="hljs-keyword">typename</span> <span class="hljs-keyword">op_t</span>, <span class="hljs-keyword">typename</span> reduction_it&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">scan</span><span class="hljs-params">(input_it input, <span class="hljs-keyword">int</span> count, output_it output, op_t op, 
  reduction_it reduction, context_t&amp; context)</span></span>;

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">scan_type_t</span> scan_type = scan_type_exc, 
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">launch_arg_t</span> = <span class="hljs-keyword">empty_t</span>, 
  <span class="hljs-keyword">typename</span> input_it, <span class="hljs-keyword">typename</span> output_it&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">scan</span><span class="hljs-params">(input_it input, <span class="hljs-keyword">int</span> count, output_it output, context_t&amp; context)</span></span>;

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">scan_type_t</span> scan_type = scan_type_exc, 
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">launch_arg_t</span> = <span class="hljs-keyword">empty_t</span>, <span class="hljs-keyword">typename</span> <span class="hljs-keyword">func_t</span>, <span class="hljs-keyword">typename</span> output_it,
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">op_t</span>, <span class="hljs-keyword">typename</span> reduction_it&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">transform_scan_event</span><span class="hljs-params">(func_t f, <span class="hljs-keyword">int</span> count, output_it output, op_t op,
  reduction_it reduction, context_t&amp; context, cudaEvent_t event)</span></span>;

<span class="hljs-keyword">template</span>&lt;
  <span class="hljs-keyword">scan_type_t</span> scan_type = scan_type_exc, <span class="hljs-comment">// scan_type_exc or scan_type_inc.</span>
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">launch_arg_t</span> = <span class="hljs-keyword">empty_t</span>, 
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">func_t</span>,         <span class="hljs-comment">// implements type_t operator()(int index).</span>
  <span class="hljs-keyword">typename</span> output_it,
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">op_t</span>,           <span class="hljs-comment">// implements type_t operator()(type_t a, type_t b).   </span>
  <span class="hljs-keyword">typename</span> reduction_it    <span class="hljs-comment">// iterator for storing the scalar reduction</span>
                           <span class="hljs-comment">//   pass discard_iterator_t&lt;type_t&gt;() to ignore </span>
                           <span class="hljs-comment">//   the reduction.</span>
&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">transform_scan</span><span class="hljs-params">(func_t f, <span class="hljs-keyword">int</span> count, output_it output, op_t op,
  reduction_it reduction, context_t&amp; context)</span></span>;
</code></pre>
<p>The prefix sum implementation <code>scan</code> has several overloads for convenience. The scan is implemented as three kernels: an upsweep that reduces values mapped into tiles; a spine which scans the partial reductions and stores the total reduction of the array; and a downsweep which distributes the scanned partials and completes the scan. </p>
<p>Because of this structure, the reduction is computed about a third of the way through the reduction. (One load for the upsweep; one load and one store for the downsweep.) The caller may need the reduction as soon as possible to allocate memory and schedule more work. Rather than suffer the latency of waiting for <code>scan</code> to return and copying the reduction from device to host memory, the user can allocate space in page-locked host memory and call <code>scan_event</code> or <code>transform_scan_event</code> to store the reduction directly into this host memory. The caller provides an event which is recorded when the reduction is computed. When <code>scan_event</code> returns the caller can synchronize on the event and read the reduction directly out of page-locked memory. This relieves the code from waiting for the downsweep kernel to complete before getting the reduction.</p>
<h4 id="merge">merge</h4>
<p><strong><code>kernel_merge.hxx</code></strong></p>
<pre><code class="lang-cpp"><span class="hljs-comment">// Key-value merge.</span>
<span class="hljs-keyword">template</span>&lt;
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">launch_arg_t</span> = <span class="hljs-keyword">empty_t</span>,
  <span class="hljs-keyword">typename</span> a_keys_it, <span class="hljs-keyword">typename</span> a_vals_it, <span class="hljs-comment">// A source keys and values</span>
  <span class="hljs-keyword">typename</span> b_keys_it, <span class="hljs-keyword">typename</span> b_vals_it, <span class="hljs-comment">// B source keys and values</span>
  <span class="hljs-keyword">typename</span> c_keys_it, <span class="hljs-keyword">typename</span> c_vals_it, <span class="hljs-comment">// C dest keys and values</span>
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">comp_t</span>         <span class="hljs-comment">// implements bool operator()(type_t a, type_t b)</span>
                          <span class="hljs-comment">//   computes a &lt; b.</span>
&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(a_keys_it a_keys, a_vals_it a_vals, <span class="hljs-keyword">int</span> a_count, 
  b_keys_it b_keys, b_vals_it b_vals, <span class="hljs-keyword">int</span> b_count,
  c_keys_it c_keys, c_vals_it c_vals, comp_t comp, context_t&amp; context)</span></span>;

<span class="hljs-comment">// Key-only merge.</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> <span class="hljs-keyword">launch_t</span> = <span class="hljs-keyword">empty_t</span>,
  <span class="hljs-keyword">typename</span> a_keys_it, <span class="hljs-keyword">typename</span> b_keys_it, <span class="hljs-keyword">typename</span> c_keys_it,
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">comp_t</span>&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(a_keys_it a_keys, <span class="hljs-keyword">int</span> a_count, b_keys_it b_keys, <span class="hljs-keyword">int</span> b_count,
  c_keys_it c_keys, comp_t comp, context_t&amp; context)</span></span>;
</code></pre>
<h4 id="sortedsearch">sorted_search</h4>
<p><strong><code>kernel_sortedsearch.hxx</code></strong></p>
<pre><code class="lang-cpp"><span class="hljs-keyword">template</span>&lt;
  <span class="hljs-keyword">bounds_t</span> bounds,         <span class="hljs-comment">// bounds_lower or bounds_upper</span>
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">launch_arg_t</span> = <span class="hljs-keyword">empty_t</span>,
  <span class="hljs-keyword">typename</span> needles_it,     <span class="hljs-comment">// search to find the insertion index of each</span>
  <span class="hljs-keyword">typename</span> haystack_it,    <span class="hljs-comment">//   sorted needle into the sorted haystack.</span>
  <span class="hljs-keyword">typename</span> indices_it,     <span class="hljs-comment">// output integer indices. </span>
                           <span class="hljs-comment">//   sized to the number of needles.</span>
  <span class="hljs-keyword">typename</span> comp_it         <span class="hljs-comment">// implements bool operator()(type_t a, type_t b)</span>
                           <span class="hljs-comment">//   computes a &lt; b.</span>
&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sorted_search</span><span class="hljs-params">(needles_it needles, <span class="hljs-keyword">int</span> num_needles, haystack_it haystack,
  <span class="hljs-keyword">int</span> num_haystack, indices_it indices, comp_it comp, context_t&amp; context)</span></span>;
</code></pre>
<p><code>sorted_search</code> is a vectorized searching algorithm. It&apos;s equivalent to calling <code>std::lower_bound</code> or <code>std::upper_bound</code> into the haystack array for each key in the needles array. We could easily implement a parallel binary search on the GPU, and it would have cost O(A log B).</p>
<p>But we can do better if the keys in the needles array are themselves sorted. Rather than process each needle individually using a binary search, the threads cooperatively compute the entire output array <code>indices</code> as a single merge-like operation. Consider comparing the front of the haystack array to the front of the needles array. If <code>*haystack &lt; *needles</code>, we advance the <code>haystack</code> pointer. Otherwise we store the index of <code>haystack</code> to the <code>indices</code> results array at the <code>needles</code> index and advance the <code>needles</code> index.</p>
<p>The cost of <code>sorted_search</code> is O(A + B) and the routine is easily load-balanced over all available processing units. This function is helpful when implementing key-matching operations like <a href="#relational-join">relational join</a>.</p>
<h4 id="bulkinsert">bulk_insert</h4>
<p><strong><code>kernel_bulkinsert.hxx</code></strong></p>
<pre><code class="lang-cpp"><span class="hljs-comment">// Insert the values at a_keys before the values at b_keys identified by</span>
<span class="hljs-comment">// insert.</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> <span class="hljs-keyword">launch_t</span> = <span class="hljs-keyword">empty_t</span>, <span class="hljs-keyword">typename</span> a_it, <span class="hljs-keyword">typename</span> insert_it, 
  <span class="hljs-keyword">typename</span> b_it, <span class="hljs-keyword">typename</span> c_it&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bulk_insert</span><span class="hljs-params">(a_it a, insert_it a_insert, <span class="hljs-keyword">int</span> insert_size, b_it b, 
  <span class="hljs-keyword">int</span> source_size, c_it c, context_t&amp; context)</span></span>;
</code></pre>
<h4 id="bulkremove">bulk_remove</h4>
<p><strong><code>kernel_bulkremove.hxx</code></strong></p>
<pre><code class="lang-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> <span class="hljs-keyword">launch_arg_t</span> = <span class="hljs-keyword">empty_t</span>,
  <span class="hljs-keyword">typename</span> input_it, <span class="hljs-keyword">typename</span> indices_it, <span class="hljs-keyword">typename</span> output_it&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bulk_remove</span><span class="hljs-params">(input_it input, <span class="hljs-keyword">int</span> count, indices_it indices, 
  <span class="hljs-keyword">int</span> num_indices, output_it output, context_t&amp; context)</span></span>;
</code></pre>
<h4 id="mergesort">mergesort</h4>
<p><strong><code>kernel_mergesort.hxx</code></strong></p>
<pre><code class="lang-cpp"><span class="hljs-comment">// Key-value sort.</span>
<span class="hljs-keyword">template</span>&lt;
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">launch_arg_t</span> = <span class="hljs-keyword">empty_t</span>, 
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">key_t</span>,          <span class="hljs-comment">// key type.</span>
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">val_t</span>,          <span class="hljs-comment">// value type.</span>
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">comp_t</span>          <span class="hljs-comment">// implements bool operator()(type_t a, type_t b)</span>
                           <span class="hljs-comment">//   computes a &lt; b.</span>
&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergesort</span><span class="hljs-params">(key_t* keys_input, val_t* vals_input, <span class="hljs-keyword">int</span> count,
  comp_t comp, context_t&amp; context)</span></span>;

<span class="hljs-comment">// Key-only sort.</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> <span class="hljs-keyword">launch_arg_t</span> = <span class="hljs-keyword">empty_t</span>, <span class="hljs-keyword">typename</span> <span class="hljs-keyword">key_t</span>, <span class="hljs-keyword">typename</span> <span class="hljs-keyword">comp_t</span>&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergesort</span><span class="hljs-params">(key_t* keys_input, <span class="hljs-keyword">int</span> count, comp_t comp, 
  context_t&amp; context)</span></span>;
</code></pre>
<p>Sort keys or key-value pairs. Unlike most other functions in moderngpu, this takes no iterators and transforms arrays in place.</p>
<h4 id="segmentedsort">segmented_sort</h4>
<p><strong><code>kernel_segsort.hxx</code></strong></p>
<pre><code class="lang-cpp"><span class="hljs-comment">// Key-value segmented sort.</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> <span class="hljs-keyword">launch_arg_t</span> = <span class="hljs-keyword">empty_t</span>, <span class="hljs-keyword">typename</span> <span class="hljs-keyword">key_t</span>, <span class="hljs-keyword">typename</span> <span class="hljs-keyword">val_t</span>,
  <span class="hljs-keyword">typename</span> seg_it, <span class="hljs-keyword">typename</span> <span class="hljs-keyword">comp_t</span>&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">segmented_sort</span><span class="hljs-params">(key_t* keys_input, val_t* vals_input, <span class="hljs-keyword">int</span> count,
  seg_it segments, <span class="hljs-keyword">int</span> num_segments, comp_t comp, context_t&amp; context)</span></span>;

<span class="hljs-comment">// Key-value segmented sort. Automatically generate indices to sort as values.</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> <span class="hljs-keyword">launch_arg_t</span> = <span class="hljs-keyword">empty_t</span>, <span class="hljs-keyword">typename</span> <span class="hljs-keyword">key_t</span>, <span class="hljs-keyword">typename</span> seg_it, 
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">comp_t</span>&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">segmented_sort_indices</span><span class="hljs-params">(key_t* keys, <span class="hljs-keyword">int</span>* indices, <span class="hljs-keyword">int</span> count, 
  seg_it segments, <span class="hljs-keyword">int</span> num_segments, comp_t comp, context_t&amp; context)</span></span>;

<span class="hljs-comment">// Key-only segmented sort.</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> <span class="hljs-keyword">launch_arg_t</span> = <span class="hljs-keyword">empty_t</span>, <span class="hljs-keyword">typename</span> <span class="hljs-keyword">key_t</span>, <span class="hljs-keyword">typename</span> seg_it, 
  <span class="hljs-keyword">typename</span> <span class="hljs-keyword">comp_t</span>&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">segmented_sort</span><span class="hljs-params">(key_t* keys_input, <span class="hljs-keyword">int</span> count, seg_it segments, 
  <span class="hljs-keyword">int</span> num_segments, comp_t comp, context_t&amp; context)</span></span>;
</code></pre>
<p>Sort keys or key-value pairs in place. This function sorts elements within segments and denoted by the segments-descriptor array. <code>segmented_sort_indices</code> ignores the initial contents of <code>indices</code> and on return stores there the gather indices of the keys.</p>
<h4 id="innerjoin">inner_join</h4>
<p><strong><code>kernel_join.hxx</code></strong></p>
<pre><code class="lang-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> <span class="hljs-keyword">launch_arg_t</span> = <span class="hljs-keyword">empty_t</span>, 
  <span class="hljs-keyword">typename</span> a_it, <span class="hljs-keyword">typename</span> b_it, <span class="hljs-keyword">typename</span> <span class="hljs-keyword">comp_t</span>&gt;
<span class="hljs-keyword">mem_t</span>&lt;int2&gt; inner_join(a_it a, <span class="hljs-keyword">int</span> a_count, b_it b, <span class="hljs-keyword">int</span> b_count, 
  <span class="hljs-keyword">comp_t</span> comp, <span class="hljs-keyword">context_t</span>&amp; context);
</code></pre>
<h4 id="loadbalancesearch">load_balance_search</h4>
<h4 id="intervalmove">interval_move</h4>
<p><strong><code>kernel_intervalmove.hxx</code></strong></p>
<pre><code class="lang-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> <span class="hljs-keyword">launch_arg_t</span> = <span class="hljs-keyword">empty_t</span>, <span class="hljs-keyword">typename</span> input_it, 
  <span class="hljs-keyword">typename</span> segments_it, <span class="hljs-keyword">typename</span> output_it&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">interval_expand</span><span class="hljs-params">(input_it input, <span class="hljs-keyword">int</span> count, segments_it segments,
  <span class="hljs-keyword">int</span> num_segments, output_it output, context_t&amp; context)</span></span>;

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> <span class="hljs-keyword">launch_arg_t</span> = <span class="hljs-keyword">empty_t</span>, <span class="hljs-keyword">typename</span> input_it, 
  <span class="hljs-keyword">typename</span> segments_it, <span class="hljs-keyword">typename</span> gather_it, <span class="hljs-keyword">typename</span> output_it&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">interval_gather</span><span class="hljs-params">(input_it input, <span class="hljs-keyword">int</span> count, segments_it segments,
  <span class="hljs-keyword">int</span> num_segments, gather_it gather, output_it output, context_t&amp; context)</span></span>;

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> <span class="hljs-keyword">launch_arg_t</span> = <span class="hljs-keyword">empty_t</span>, <span class="hljs-keyword">typename</span> input_it, 
  <span class="hljs-keyword">typename</span> segments_it, <span class="hljs-keyword">typename</span> scatter_it, <span class="hljs-keyword">typename</span> output_it&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">interval_scatter</span><span class="hljs-params">(input_it input, <span class="hljs-keyword">int</span> count, segments_it segments,
  <span class="hljs-keyword">int</span> num_segments, scatter_it scatter, output_it output, context_t&amp; context)</span></span>;

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> <span class="hljs-keyword">launch_arg_t</span> = <span class="hljs-keyword">empty_t</span>, 
  <span class="hljs-keyword">typename</span> input_it, <span class="hljs-keyword">typename</span> segments_it, <span class="hljs-keyword">typename</span> scatter_it,
  <span class="hljs-keyword">typename</span> gather_it, <span class="hljs-keyword">typename</span> output_it&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">interval_move</span><span class="hljs-params">(input_it input, <span class="hljs-keyword">int</span> count, segments_it segments,
  <span class="hljs-keyword">int</span> num_segments, scatter_it scatter, gather_it gather, output_it output, 
  context_t&amp; context)</span></span>;
</code></pre>
<h4 id="innerjoin">inner_join</h4>
<p><strong><code>kernel_join.hxx</code></strong></p>
<pre><code class="lang-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> <span class="hljs-keyword">launch_arg_t</span> = <span class="hljs-keyword">empty_t</span>, 
  <span class="hljs-keyword">typename</span> a_it, <span class="hljs-keyword">typename</span> b_it, <span class="hljs-keyword">typename</span> <span class="hljs-keyword">comp_t</span>&gt;
<span class="hljs-keyword">mem_t</span>&lt;int2&gt; inner_join(a_it a, <span class="hljs-keyword">int</span> a_count, b_it b, <span class="hljs-keyword">int</span> b_count, 
  <span class="hljs-keyword">comp_t</span> comp, <span class="hljs-keyword">context_t</span>&amp; context);
</code></pre>
<h4 id="segreduce">segreduce</h4>
<p><strong><code>kernel_segreduce.hxx</code></strong></p>
<pre><code class="lang-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> <span class="hljs-keyword">launch_arg_t</span> = <span class="hljs-keyword">empty_t</span>, <span class="hljs-keyword">typename</span> input_it,
  <span class="hljs-keyword">typename</span> segments_it, <span class="hljs-keyword">typename</span> output_it, <span class="hljs-keyword">typename</span> <span class="hljs-keyword">op_t</span>, <span class="hljs-keyword">typename</span> <span class="hljs-keyword">type_t</span>&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">segreduce</span><span class="hljs-params">(input_it input, <span class="hljs-keyword">int</span> count, segments_it segments, 
  <span class="hljs-keyword">int</span> num_segments, output_it output, op_t op, type_t init, 
  context_t&amp; context)</span></span>;

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> <span class="hljs-keyword">launch_arg_t</span> = <span class="hljs-keyword">empty_t</span>, <span class="hljs-keyword">typename</span> matrix_it,
  <span class="hljs-keyword">typename</span> columns_it, <span class="hljs-keyword">typename</span> vector_it, <span class="hljs-keyword">typename</span> segments_it, 
  <span class="hljs-keyword">typename</span> output_it&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">spmv</span><span class="hljs-params">(matrix_it matrix, columns_it columns, vector_it <span class="hljs-built_in">vector</span>,
  <span class="hljs-keyword">int</span> count, segments_it segments, <span class="hljs-keyword">int</span> num_segments, output_it output,
  context_t&amp; context)</span></span>;
</code></pre>

                    
                    </section>
                
                
                </div>
            </div>
        </div>

        
        <a href="../doc/lbs.html" class="navigation navigation-prev " aria-label="Previous page: Load-balancing search"><i class="fa fa-angle-left"></i></a>
        
        
        <a href="../doc/usage.html" class="navigation navigation-next " aria-label="Next page: Usage notes"><i class="fa fa-angle-right"></i></a>
        
    </div>
</div>

        
<script src="../gitbook/app.js"></script>

    
    <script src="../gitbook/plugins/gitbook-plugin-search/lunr.min.js"></script>
    

    
    <script src="../gitbook/plugins/gitbook-plugin-search/search.js"></script>
    

    
    <script src="../gitbook/plugins/gitbook-plugin-sharing/buttons.js"></script>
    

    
    <script src="../gitbook/plugins/gitbook-plugin-fontsettings/buttons.js"></script>
    

<script>
require(["gitbook"], function(gitbook) {
    var config = {"highlight":{},"search":{"maxIndexSize":1000000},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2}};
    gitbook.start(config);
});
</script>

        
    </body>
    
</html>
